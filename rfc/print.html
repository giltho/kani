<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kani RFC Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Design documents for Kani Rust Verifier">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="template.html">RFC Template</a></li><li class="chapter-item expanded affix "><li class="part-title">Kani RFCs</li><li class="chapter-item expanded "><a href="rfcs/0001-mir-linker.html">0001-mir-linker</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kani RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/model-checking/kani" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Kani is an open-source verification tool that uses automated reasoning to analyze Rust programs. In order to
integrate feedback from developers and users on future changes to Kani, we decided to follow a light-weight
&quot;RFC&quot; (request for comments) process.</p>
<h2 id="when-to-create-an-rfc"><a class="header" href="#when-to-create-an-rfc">When to create an RFC</a></h2>
<p>You should create an RFC in one of two cases:</p>
<ol>
<li>The change you are proposing would be a &quot;one way door&quot;: e.g. a change to the public API, a new feature that would be difficult to modify once released, deprecating a feature, etc.</li>
<li>The change you are making has a significant design component, and would benefit from a design review.</li>
</ol>
<p>Bugs and smaller improvements to existing features do not require an RFC.
If you are in doubt, feel free to create  a <a href="https://github.com/model-checking/kani/issues/new?assignees=&amp;labels=&amp;template=feature_request.md">feature request</a> and discuss the next steps in the new issue.
Your PR reviewer may also request an RFC if your change appears to fall into category 1 or 2.</p>
<p>You do not necessarily need to create an RFC immediately. It is our experience that it is often best to write some &quot;proof of concept&quot; code to test out possible ideas before writing the formal RFC.</p>
<h2 id="the-rfc-process"><a class="header" href="#the-rfc-process">The RFC process</a></h2>
<p>This is the overall workflow for the RFC process:</p>
<pre><code class="language-toml">    Create RFC ──&gt; Receive Feedback  ──&gt; Accepted?
                        │  ∧                  │ Y
                        ∨  │                  ├───&gt; Implement ───&gt; Test + Feedback ───&gt; Stabilize?
                       Revise                 │ N                                          │ Y
                                              └───&gt; Close PR                               ├───&gt; RFC Stable
                                                                                           │ N
                                                                                           └───&gt; Remove feature
</code></pre>
<ol>
<li>Create an RFC
<ol>
<li>Create a tracking issue for your RFC (e.g.: <a href="https://github.com/model-checking/kani/issues/1588">Issue-1588</a>).</li>
<li>Start from a fork of the Kani repository.</li>
<li>Copy the template file (<a href="./template.html"><code>rfc/src/template.md</code></a>) to <code>rfc/src/&lt;ID_NUMBER&gt;&lt;my-feature&gt;.md</code>.</li>
<li>Fill in the details according to the template instructions.</li>
<li>Submit a pull request.</li>
</ol>
</li>
<li>Build consensus and integrate feedback.
<ol>
<li>RFCs should get approved by at least 2 Kani developers.</li>
<li>Once the RFC has been approved, update the RFC status and merge the PR.</li>
<li>If the RFC is not approved, close the PR without merging.</li>
</ol>
</li>
<li>Feature implementation.
<ol>
<li>Start implementing the new feature in your fork.</li>
<li>It is OK to implement it incrementally over multiple PRs. Just ensure that every pull request has a testable
end-to-end flow and that it is properly tested.</li>
<li>In the implementation stage, the feature should only be accessible if the user explicitly passes
<code>--enable-unstable</code> as an argument to Kani.</li>
<li>Document how to use the feature.</li>
<li>Keep the RFC up-to-date with the decisions you make during implementation.</li>
</ol>
</li>
<li>Test and Gather Feedback.
<ol>
<li>Fix major issues related to the new feature.</li>
<li>Gather user feedback and make necessary adjustments.</li>
<li>Add lots of tests.</li>
</ol>
</li>
<li>Stabilization.
<ol>
<li>Propose to stabilize the feature when feature is well tested and UX has received positive feedback.</li>
<li>Create a new PR that removes the <code>--enable-unstable</code> guard and that marks the RFC status as &quot;STABLE&quot;.
<ol>
<li>Make sure the RFC reflects the final implementation and user experience.</li>
</ol>
</li>
<li>In some cases, we might decide not to incorporate a feature
(E.g.: performance degradation, bad user experience, better alternative).
In those cases, please update the RFC status to &quot;CANCELLED as per &lt;PR_LINK | ISSUE_LINK&gt;&quot; and remove the code
that is no longer relevant.</li>
<li>Close the tracking issue.</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> <em>Fill me with pretty name and a unique ident. E.g: New Feature (<code>new_feature</code>)</em></li>
<li><strong>Feature Request Issue:</strong> <em>Link to issue</em></li>
<li><strong>RFC PR:</strong> <em>Link to original PR</em></li>
<li><strong>Status:</strong> <em>One of the following: [Under Review | Unstable | Stable | Cancelled]</em></li>
<li><strong>Version:</strong> [0-9]* <em>Increment this version whenever you open a new PR to update the RFC (not at every revision).
Start with 0.</em></li>
<li><strong>Proof-of-concept:</strong> <em>Optional field. If you have implemented a proof of concept, add a link here</em></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Short description of the feature, i.e.: the elevator pitch. What is this feature about?</p>
<h2 id="user-impact"><a class="header" href="#user-impact">User Impact</a></h2>
<p>Why are we doing this? How will this benefit the final user?</p>
<ul>
<li>If this is an API change, how will that impact current users?</li>
<li>For deprecation or breaking changes, how will the transition look like?</li>
<li>If this RFC is related to change in the architecture without major user impact, think about the long term
impact for user. I.e.: what future work will this enable.</li>
</ul>
<h2 id="user-experience"><a class="header" href="#user-experience">User Experience</a></h2>
<p>What is the scope of this RFC? Which use cases do you have in mind? Explain how users will interact with it. Also
please include:</p>
<ul>
<li>How would you teach this feature to users? What changes will be required to the user documentation?</li>
<li>If the RFC is related to architectural changes and there are no visible changes to UX, please state so.</li>
</ul>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed Design</a></h2>
<p>This is the technical portion of the RFC. Please provide high level details of the implementation you have in mind:</p>
<ul>
<li>What are the main components that will be modified? (E.g.: changes to <code>kani-compiler</code>, <code>kani-driver</code>, metadata,
installation...)</li>
<li>How will they be modified? Any changes to how these components communicate?</li>
<li>Will this require any new dependency?</li>
<li>What corner cases do you anticipate?</li>
</ul>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<ul>
<li>What are the pros and cons of this design?</li>
<li>What is the impact of not doing this?</li>
<li>What other designs have you considered? Why didn't you choose them?</li>
</ul>
<h2 id="open-questions"><a class="header" href="#open-questions">Open questions</a></h2>
<ul>
<li>Is there any part of the design that you expect to resolve through the RFC process?</li>
<li>What kind of user feedback do you expect to gather before stabilization? How will this impact your design?</li>
</ul>
<h2 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h2>
<p>What are natural extensions and possible improvements that you predict for this feature that is out of the
scope of this RFC? Feel free to brainstorm here.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Feature Name:</strong> MIR Linker (mir_linker)</li>
<li><strong>RFC Tracking Issue</strong>: <a href="https://github.com/model-checking/kani/issues/1588">https://github.com/model-checking/kani/issues/1588</a></li>
<li><strong>RFC PR:</strong> <a href="https://github.com/model-checking/kani/pull/1600">https://github.com/model-checking/kani/pull/1600</a></li>
<li><strong>Status:</strong> Under Review</li>
<li><strong>Version:</strong> 0</li>
</ul>
<hr />
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Fix linking issues with the rust standard library in a scalable manner by only generating goto-program for
code that is reachable from the user harnesses.</p>
<h2 id="user-impact-1"><a class="header" href="#user-impact-1">User Impact</a></h2>
<p>The main goal of this RFC is to enable Kani users to link against all supported constructs from the <code>std</code> library.
Currently, Kani will only link to items that are either generic or have an inline annotation.</p>
<p>The approach introduced in this RFC will have the following secondary benefits.</p>
<ul>
<li>Reduce spurious warnings about unsupported features for cases where the feature is not reachable from any harness.</li>
<li>In the verification mode, we will likely see a reduction on the compilation time and memory consumption
by pruning the inputs of symtab2gb and goto-instrument.
<ul>
<li>Compared to linking against the standard library goto-models that take more than 5 GB.</li>
</ul>
</li>
<li>In a potential assessment mode, only analyze code that is reachable from all public items in the target crate.</li>
</ul>
<p>One downside is that if we decide to include a pre-compiled version of the std, our release bundle will double in size
(See <a href="rfcs/0001-mir-linker.html#rational-and-alternatives">Rational and Alternatives</a>
for more information on the size overhead).
This will negatively impact the time taken to set up Kani
(triggered by either the first time a user invokes <code>kani | cargo-kani</code> , or explicit invoke the subcommand <code>setup</code>).</p>
<h2 id="user-experience-1"><a class="header" href="#user-experience-1">User Experience</a></h2>
<p>Once this RFC has been stabilized users shall use Kani in the same manner as they have been today.
Until then, we wil add an unstable option <code>--mir-linker</code> to enable the cross-crate reachability analysis
and the generation of the goto-program only when compiling the target crate.</p>
<p>Kani setup will likely take longer and more disk space as mentioned in the section above.
This change will not be guarded by <code>--mir-linker</code> option above.</p>
<h2 id="detailed-design-1"><a class="header" href="#detailed-design-1">Detailed Design</a></h2>
<p>In a nutshell, we will no longer generate a goto-program for every crate we compile.
Instead, we will generate the MIR for every crate, and we will generate only one goto-program.
This model will only include items reachable from the target crate's harnesses.</p>
<p>The current system flow for a crate verification is the following (Kani here represents either <code>kani | cargo-kani</code>
executable):</p>
<ol>
<li>Kani compiles the user crate as well as all its dependencies.
For every crate compiled, <code>kani-compiler</code> will generate a goto-program.
This model includes everything reachable from the crate's public functions.</li>
<li>After that, Kani links all models together by invoking <code>goto-cc</code>.
This step will also link against Kani's <code>C</code> library.</li>
<li>For every harness, Kani invokes <code>goto-instrument</code> to prune the linked model to only include items reachable from the given harness.</li>
<li>Finally, Kani instruments and verify each harness model via <code>goto-instrument</code> and <code>cbmc</code> calls.</li>
</ol>
<p>After this RFC, the system flow would be slightly different:</p>
<ol>
<li>Kani compiles the user crate dependencies up to the MIR translation.
I.e., for every crate compiled, <code>kani-compiler</code> will generate an artifact that includes the MIR representation
of all items in the crate.</li>
<li>Kani will generate the goto-program only while compiling the target user crate.
It will generate one goto-program that includes all items reachable from any harness in the target crate.</li>
<li><code>goto-cc</code> will still be invoked to link the generated model against Kani's <code>C</code> library.</li>
<li>Steps #3 and #4 above will be performed without any change.</li>
</ol>
<p>This feature will require three main changes to Kani which are detailed in the sub-sections below.</p>
<h3 id="kanis-sysroot"><a class="header" href="#kanis-sysroot">Kani's Sysroot</a></h3>
<p>Kani currently uses <code>rustup</code> sysroot to gather information from the standard library constructs.
The artifacts from this <code>sysroot</code> include the MIR for generic items as well as for items that may be included in
a crate compilation (e.g.: functions marked with <code>#[inline]</code> annotation).
The artifacts do not include the MIR for items that have already been compiled to the <code>std</code> shared library.
This leaves a gap that cannot be filled by the <code>kani-compiler</code>;
thus, we are unable to translate these items into goto-program.</p>
<p>In order to fulfill this gap, we must compile the standard library from scratch.
This RFC proposes a similar method to what <a href="https://github.com/rust-lang/miri"><code>MIRI</code></a> implements.
We will generate our own sysroot using the <code>-Z always-encode-mir</code> compilation flag.
This sysroot will be pre-compiled and included in our release bundle.</p>
<p>We will compile <code>kani</code>'s libraries (<code>kani</code> and <code>std</code>) also with <code>-Z always-encode-mir</code>
and with the new sysroot.</p>
<h3 id="cross-crate-reachability-analysis"><a class="header" href="#cross-crate-reachability-analysis">Cross-Crate Reachability Analysis</a></h3>
<p><code>kani-compiler</code> will include a new <code>reachability</code> module to traverse over the local and external MIR items.
This module will <code>monomorphize</code> all generic code as it's performing the traversal.</p>
<p>The traversal logic will be customizable allowing different starting points to be used.
The two options to be included in this RFC is starting from all local harnesses
(tagged with <code>#[kani::proof]</code>) and all public functions in the local crate.</p>
<p>The <code>kani-compiler</code> behavior will be customizable via a new flag:</p>
<pre><code>--reachability=[ harnesses | pub_fns |  none | legacy ]
</code></pre>
<p>where:</p>
<ul>
<li><code>harnesses</code>: Use the local harnesses as the starting points for the reachability analysis.</li>
<li><code>pub_fns</code>: Use the public local functions as the starting points for the reachability analysis.</li>
<li><code>none</code>: This will be the default value if <code>--reachability</code> flag is not provided. It will skip
reachability analysis. No goto-program will be generated.
This will be used to compile dependencies up to the MIR level.
<code>kani-compiler</code> will still generate artifacts with the crate's MIR.</li>
<li><code>legacy</code>: Keep <code>kani-compiler</code> current behavior by using
<code>rustc_monomorphizer::collect_and_partition_mono_items()</code> which respects the crate boundary.
This will generate a goto-program for each crate compiled by <code>kani-compiler</code>, and it will still have the same
<code>std</code> linking issues.
<em>This option will be removed as part of the <code>rfc</code> stabilization.</em></li>
</ul>
<p>These flags will not be exposed to the final user.
They will only be used for the communication between <code>kani-driver</code> and <code>kani-compiler</code>.</p>
<h3 id="dependencies-vs-target-crate-compilation"><a class="header" href="#dependencies-vs-target-crate-compilation">Dependencies vs Target Crate Compilation</a></h3>
<p>The flags described in the section above will be used by <code>kani-driver</code> to implement the new system flow.
For that, we propose the following mechanism:</p>
<ul>
<li>
<p>For standalone <code>kani</code>, we will pass the option <code>--reachability=harnesses</code> to <code>kani-compiler</code>.</p>
</li>
<li>
<p>For <code>cargo-kani</code>, we will replace</p>
<pre><code>cargo build &lt;FLAGS&gt;
</code></pre>
<p>with:</p>
<pre><code>cargo rustc &lt;FLAGS&gt; -- --reachability=harnesses
</code></pre>
<p>to build everything.
This command will compile all dependencies without the <code>--reachability</code> argument, and it will only pass <code>harnesses</code>
value to the compiler when compiling the target crate.</p>
</li>
</ul>
<h2 id="rational-and-alternatives"><a class="header" href="#rational-and-alternatives">Rational and Alternatives</a></h2>
<p>Not doing anything is not an alternative, since this fixes a major gap in Kani's usability.</p>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<ul>
<li>The MIR linker will allow us to fix the linking issues with Rust's standard library.</li>
<li>Once stabilized, the MIR linker will be transparent to the user.</li>
<li>It will enable more powerful and precise static analysis to <code>kani-compiler</code>.</li>
<li>It won't require any changes to our dependencies.</li>
<li>This will fix the harnesses' dependency on the<code>#[no_mangle]</code> annotation
(<a href="https://github.com/model-checking/kani/issues/661">Issue-661</a>).</li>
</ul>
<h3 id="risks"><a class="header" href="#risks">Risks</a></h3>
<p>Failures in the linking stage would not impact the tool soundness. I anticipate the following failure scenarios:</p>
<ul>
<li>ICE (Internal compiler error): Some logic is incorrectly implemented and the linking stage crashes.
Although this is a bad experience for the user, this will not impact the verification result.</li>
<li>Missing items: This would either result in ICE during code generation or a verification failure if the missing
item is reachable.</li>
<li>Extra items: This shouldn't impact the verification results, and they should be pruned by CBMC's reachability
analysis.
This is already the case today. In extreme cases, this could include a symbol that we cannot compile and cause an ICE.</li>
</ul>
<p>The new reachability code would be highly dependent on the <code>rustc</code> unstable APIs, which could increase
the cost of the upstream synchronization.
That said, the APIs that would be required are already used today.</p>
<p>Finally, this implementation relies on a few unstable options from <code>cargo</code> and <code>rustc</code>.
These APIs are used by other tools such as MIRI, so we don't see a high risk that they would be removed.</p>
<h3 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h3>
<p>The other options explored were:</p>
<ol>
<li>Pre-compile the standard library, and the kani library, and ship the generated <code>*symtab.json</code> files.</li>
<li>Pre-compile the standard library, and the kani library, convert the standard library and dependencies to goto-program
(via<code>symtab2gb</code>) and link them into one single goto-program.
Ship the generated model.</li>
</ol>
<p>Both would still require shipping the compiler metadata (via <code>rlib</code> or <code>rmeta</code>) for the kani library, its
dependencies, and <code>kani_macro.so</code>.</p>
<p>Both alternatives are very similar. They only differ on the artifact that would be shipped.
They require generating and shipping a custom <code>sysroot</code>;
however, there is no need to implement the reachability algorithm.</p>
<p>We implemented a prototype for the MIR linker and one for the alternatives.
Both prototypes generate the sysroot as part of the <code>cargo kani</code> flow.</p>
<p>We performed a small experiment (on a <code>c5.4xlarge</code> ec2 instance running Ubuntu 20.04) to assess the options.</p>
<p>For this experiment, we used the following harness:</p>
<pre><code class="language-rust">#[kani::proof]
#[kani::unwind(4)]
pub fn check_format() {
    assert!(&quot;2&quot;.parse::&lt;u32&gt;().unwrap() == 2);
}
</code></pre>
<p>The experiment showed that the MIR linker approach is much more efficient.</p>
<p>See the table bellow for the breakdown of time (in seconds) taken for each major step of
the harness verification:</p>
<table><thead><tr><th>Stage</th><th>MIR Linker</th><th>Alternative</th></tr></thead><tbody>
<tr><td>compilation</td><td>22.2s</td><td>64.7s</td></tr>
<tr><td>goto-program generation</td><td>2.4s</td><td>90.7s</td></tr>
<tr><td>goto-program linking</td><td>0.8s</td><td>33.2s</td></tr>
<tr><td>code instrumentation</td><td>0.8s</td><td>33.1</td></tr>
<tr><td>verification</td><td>0.5s</td><td>8.5s</td></tr>
</tbody></table>
<p>It is possible that <code>goto-cc</code> time can be improved, but this would also require further experimentation and
expertise that we don't have today.</p>
<p>Every option would require a custom sysroot to either be built or shipped with Kani.
The table below shows the size of the sysroot files for the alternative #2
(goto-program files) vs compiler artifacts (<code>*.rmeta</code> files)
files with <code>-Z always-encode-mir</code> for <code>x86_64-unknown-linux-gnu</code> (on Ubuntu 18.04).</p>
<table><thead><tr><th>File Type</th><th>Raw size</th><th>Compressed size</th></tr></thead><tbody>
<tr><td><code>symtab.json</code></td><td>950M</td><td>26M</td></tr>
<tr><td><code>symtab.out</code></td><td>84M</td><td>24M</td></tr>
<tr><td><code>*.rmeta</code></td><td>92M</td><td>25M</td></tr>
</tbody></table>
<p>These results were obtained by looking at the artifacts generated during the same experiment.</p>
<h2 id="open-questions-1"><a class="header" href="#open-questions-1">Open questions</a></h2>
<ul>
<li>Should we build or download the sysroot during <code>kani setup</code>?</li>
<li>What's the best way to enable support to run Kani in the entire <code>workspace</code>?
<ul>
<li>One possibility is to run <code>cargo rustc</code> per package.</li>
</ul>
</li>
<li>Should we codegen all static items no matter what? Static objects can only be initialized via constant function.
Thus, it shouldn't have any side effect.
That relies on all constant initializers being evaluated during compilation.</li>
<li>What's the best way to handle <code>cargo kani --tests</code>?
We still want to restrict the reachability and codegen to the last compilation step.
Possible solutions that we considered so far:
<ol>
<li>Add a new value to <code>--reachability</code>, maybe &quot;on-tests&quot; or something like that.
This would behave as either &quot;harness&quot; or &quot;none&quot; depending whether RUSTFLAGS has <code>--tests</code>.</li>
<li>Change how we handle not having <code>--reachability</code> argument to also take into account the existence of <code>--tests</code>.</li>
</ol>
</li>
</ul>
<h2 id="future-possibilities-1"><a class="header" href="#future-possibilities-1">Future possibilities</a></h2>
<ul>
<li>Split the goto-program into two or more items to optimize compilation result caching.
<ul>
<li>Dependencies: One model will include items from all the crate dependencies.
This model will likely be more stable and require fewer updates.</li>
<li>Target crate: The model for all items in the target crate.</li>
</ul>
</li>
<li>Do the analysis per-harness. This might be adequate once we have a mechanism to cache translations.</li>
<li>Add an option to include external functions to the analysis starting point in order to enable verification when
calls are made from <code>C</code> to <code>rust</code>.</li>
<li>Contribute the reachability analysis code back to upstream.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
